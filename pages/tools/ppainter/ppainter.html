<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>pPainter Web</title>
<style>
  body { margin:0; font-family:sans-serif; display:flex; height:100vh; }
  #toolbar { width: 60px; background: #eee; display:flex; flex-direction: column; align-items:center; padding:5px; box-sizing:border-box; }
  #toolbar button { margin:5px 0; width:48px; height:48px; }
  #sidebar { width: 200px; background:#f7f7f7; overflow:auto; padding:5px; box-sizing:border-box; }
  #canvasContainer { flex:1; display:flex; justify-content:center; align-items:center; background:#ccc; position:relative; }
  canvas { background:white; cursor:crosshair; image-rendering: pixelated; }
  .paletteColor { width:24px; height:24px; display:inline-block; margin:1px; border:1px solid #000; cursor:pointer; }
</style>
</head>
<body>

<div id="toolbar">
  <button id="brushBtn" title="Brush">üñåÔ∏è</button>
  <button id="eraserBtn" title="Eraser">üßπ</button>
  <button id="fillBtn" title="Fill">ü™£</button>
  <button id="pickerBtn" title="Picker">üé®</button>
  <button id="colorBtn" title="Choose Color">üé®</button>
  <button id="openBtn" title="Open File">üìÇ</button>
  <button id="saveBtn" title="Save File">üíæ</button>
  <button id="exportBtn" title="Export PNG">üì§</button>
</div>

<div id="sidebar">
  <h3>Palette</h3>
  <div id="paletteContainer"></div>
</div>

<div id="canvasContainer">
  <canvas id="canvas"></canvas>
</div>

<input type="file" id="fileInput" style="display:none;" />

<script>
// ======= pPainter Web =======

// Canvas setup
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let imageInfo = null; // { bpp, clut, data, width, height }
let currentTool = 'brush';
let brushColor = {r:0,g:0,b:0};
let brushIndex = 0;
let mouseDown = false;
let lastPos = null;

// DOM Elements
const paletteContainer = document.getElementById('paletteContainer');
const fileInput = document.getElementById('fileInput');

// ======= TOOL BUTTONS =======
document.getElementById('brushBtn').onclick = ()=> currentTool='brush';
document.getElementById('eraserBtn').onclick = ()=> currentTool='eraser';
document.getElementById('fillBtn').onclick = ()=> currentTool='fill';
document.getElementById('pickerBtn').onclick = ()=> currentTool='picker';
document.getElementById('colorBtn').onclick = chooseColor;
document.getElementById('openBtn').onclick = ()=> fileInput.click();
document.getElementById('saveBtn').onclick = saveFile;
document.getElementById('exportBtn').onclick = exportPNG;

fileInput.addEventListener('change', (e)=> {
  if(e.target.files.length>0) openFile(e.target.files[0]);
});

// ======= COLOR PICKER =======
function chooseColor() {
  const hex = prompt("Enter hex color (e.g. ff0000):", "000000");
  if(!hex || hex.length!==6) return;
  brushColor = { r: parseInt(hex.slice(0,2),16),
                 g: parseInt(hex.slice(2,4),16),
                 b: parseInt(hex.slice(4,6),16) };
  if(imageInfo && imageInfo.clut) {
    let bestIdx=0, bestDist=Infinity;
    imageInfo.clut.forEach((c,i)=>{
      let dr=c[0]-brushColor.r, dg=c[1]-brushColor.g, db=c[2]-brushColor.b;
      let dist=dr*dr+dg*dg+db*db;
      if(dist<bestDist){ bestDist=dist; bestIdx=i; }
    });
    brushIndex = bestIdx;
  }
}

// ======= CANVAS EVENTS =======
canvas.addEventListener('mousedown', e=>{ mouseDown=true; lastPos=getMousePos(e); paint(lastPos); });
canvas.addEventListener('mousemove', e=>{ if(mouseDown) { const pos=getMousePos(e); drawLine(lastPos,pos); lastPos=pos; }});
canvas.addEventListener('mouseup', e=>{ mouseDown=false; lastPos=null; });
canvas.addEventListener('mouseleave', e=>{ mouseDown=false; lastPos=null; });

function getMousePos(e){
  const rect = canvas.getBoundingClientRect();
  const scaleX = imageInfo.width / rect.width;
  const scaleY = imageInfo.height / rect.height;
  return { x: Math.floor((e.clientX - rect.left)*scaleX),
           y: Math.floor((e.clientY - rect.top)*scaleY) };
}

// ======= DRAWING LOGIC =======
function paint(pos){
  if(!imageInfo) return;
  const x=pos.x, y=pos.y;
  if(currentTool==='brush'){ setPixel(x,y,brushColor,brushIndex); }
  else if(currentTool==='eraser'){ 
    if(imageInfo.clut) setPixel(x,y,{r:0,g:0,b:0},0);
    else setPixel(x,y,{r:255,g:255,b:255},0);
  }
  else if(currentTool==='fill'){ floodFill(x,y); }
  else if(currentTool==='picker'){ pickColor(x,y); }
  drawCanvas();
}

function drawLine(p0,p1){
  const dx=p1.x-p0.x, dy=p1.y-p0.y;
  const steps=Math.max(Math.abs(dx),Math.abs(dy));
  for(let i=0;i<=steps;i++){
    const xi = Math.round(p0.x + dx*i/steps);
    const yi = Math.round(p0.y + dy*i/steps);
    paint({x:xi,y:yi});
  }
}

function setPixel(x,y,color,index){
  if(x<0||y<0||x>=imageInfo.width||y>=imageInfo.height) return;
  if(imageInfo.clut){ imageInfo.data[y][x]=index; }
  else{ imageInfo.data[y][x]=[color.r,color.g,color.b]; }
}

function pickColor(x,y){
  if(x<0||y<0||x>=imageInfo.width||y>=imageInfo.height) return;
  if(imageInfo.clut){ brushIndex=imageInfo.data[y][x]; brushColor={r: imageInfo.clut[brushIndex][0], g:imageInfo.clut[brushIndex][1], b:imageInfo.clut[brushIndex][2]}; }
  else{ const pix=imageInfo.data[y][x]; brushColor={r:pix[0],g:pix[1],b:pix[2]}; }
}

function floodFill(x,y){
  const w=imageInfo.width, h=imageInfo.height;
  if(imageInfo.clut){
    const target=imageInfo.data[y][x]; if(target===brushIndex) return;
    const stack=[[x,y]];
    while(stack.length){
      const [px,py]=stack.pop();
      if(px<0||py<0||px>=w||py>=h) continue;
      if(imageInfo.data[py][px]===target){
        imageInfo.data[py][px]=brushIndex;
        stack.push([px+1,py],[px-1,py],[px,py+1],[px,py-1]);
      }
    }
  } else {
    const tgt=imageInfo.data[y][x]; if(equalColor(tgt,brushColor)) return;
    const stack=[[x,y]];
    while(stack.length){
      const [px,py]=stack.pop();
      if(px<0||py<0||px>=w||py>=h) continue;
      if(equalColor(imageInfo.data[py][px],tgt)){
        imageInfo.data[py][px]=[brushColor.r,brushColor.g,brushColor.b];
        stack.push([px+1,py],[px-1,py],[px,py+1],[px,py-1]);
      }
    }
  }
}

function equalColor(a,b){ return a[0]===b.r||a[0]===b[0]&&a[1]===b.g||a[1]===b[1]&&a[2]===b.b||a[2]===b[2]; }

function drawCanvas(){
  if(!imageInfo) return;
  canvas.width=imageInfo.width; canvas.height=imageInfo.height;
  const imgData = ctx.createImageData(imageInfo.width,imageInfo.height);
  for(let y=0;y<imageInfo.height;y++){
    for(let x=0;x<imageInfo.width;x++){
      const i=(y*imageInfo.width+x)*4;
      let r,g,b;
      if(imageInfo.clut){ const idx=imageInfo.data[y][x]; [r,g,b]=imageInfo.clut[idx]; }
      else{ [r,g,b]=imageInfo.data[y][x]; }
      imgData.data[i]=r; imgData.data[i+1]=g; imgData.data[i+2]=b; imgData.data[i+3]=255;
    }
  }
  ctx.putImageData(imgData,0,0);
  drawPalette();
}

// ======= PALETTE =======
function drawPalette(){
  paletteContainer.innerHTML='';
  if(!imageInfo || !imageInfo.clut) return;
  imageInfo.clut.forEach((c,i)=>{
    const div=document.createElement('div');
    div.className='paletteColor';
    div.style.background=`rgb(${c[0]},${c[1]},${c[2]})`;
    div.onclick=()=> { brushIndex=i; brushColor={r:c[0],g:c[1],b:c[2]}; };
    paletteContainer.appendChild(div);
  });
}

// ======= FILE LOADING =======
function openFile(file){
  const reader = new FileReader();
  reader.onload = e=>{
    const data = new Uint8Array(e.target.result);
    if(file.name.toLowerCase().endsWith('.tim')){
      imageInfo=parseTIM(data);
    } else {
      const img = new Image();
      img.onload = ()=>{
        canvas.width=img.width; canvas.height=img.height;
        ctx.drawImage(img,0,0);
        const imgData=ctx.getImageData(0,0,img.width,img.height);
        const rows=[];
        for(let y=0;y<img.height;y++){
          const row=[];
          for(let x=0;x<img.width;x++){
            const i=(y*img.width+x)*4;
            row.push([imgData.data[i],imgData.data[i+1],imgData.data[i+2]]);
          }
          rows.push(row);
        }
        imageInfo={bpp:24,clut:null,data:rows,width:img.width,height:img.height};
        drawCanvas();
      };
      img.src=e.target.result;
    }
  };
  reader.readAsArrayBuffer(file);
}

// ======= TIM PARSER =======
function parseTIM(data){
  if(data[0]!==0x10) { alert("Invalid TIM"); return null; }
  const flags = data[4]|(data[5]<<8)|(data[6]<<16)|(data[7]<<24);
  const bppFlag = flags&3;
  const clutFlag = !!(flags&8);
  const bppMap = {0:4,1:8,2:16,3:24};
  const bpp = bppMap[bppFlag];
  let offset = 8;
  let clut = null;
  if(clutFlag){
    const clutSize = data[offset]|(data[offset+1]<<8)|(data[offset+2]<<16)|(data[offset+3]<<24);
    const w = data[offset+4]|(data[offset+5]<<8);
    const h = data[offset+6]|(data[offset+7]<<8);
    offset += 12;
    clut=[];
    for(let i=0;i<w*h;i++){
      const val = data[offset]|(data[offset+1]<<8);
      offset+=2;
      let r=(val&0x1F)<<3|(val&0x1C)>>2;
      let g=((val>>5)&0x1F)<<3|((val>>5)&0x1C)>>2;
      let b=((val>>10)&0x1F)<<3|((val>>10)&0x1C)>>2;
      clut.push([r,g,b]);
    }
  }
  const imgSize = data[offset]|(data[offset+1]<<8)|(data[offset+2]<<16)|(data[offset+3]<<24);
  const w16 = data[offset+4]|(data[offset+5]<<8);
  const h16 = data[offset+6]|(data[offset+7]<<8);
  offset +=12;
  const rows=[];
  if(bpp===4){
    for(let y=0;y<h16;y++){
      const row=[];
      for(let x=0;x<w16;x++){
        const word=data[offset]|(data[offset+1]<<8); offset+=2;
        for(let i=0;i<4;i++) row.push((word>>(4*i))&0xF);
      }
      rows.push(row.slice(0,w16*4));
    }
  } else if(bpp===8){
    for(let y=0;y<h16;y++){
      const row=[];
      for(let x=0;x<w16;x++){
        const word=data[offset]|(data[offset+1]<<8); offset+=2;
        row.push(word&0xFF); row.push((word>>8)&0xFF);
      }
      rows.push(row.slice(0,w16*2));
    }
  } else if(bpp===16){
    for(let y=0;y<h16;y++){
      const row=[];
      for(let x=0;x<w16;x++){
        const val=data[offset]|(data[offset+1]<<8); offset+=2;
        let r=(val&0x1F)<<3|(val&0x1C)>>2;
        let g=((val>>5)&0x1F)<<3|((val>>5)&0x1C)>>2;
        let b=((val>>10)&0x1F)<<3|((val>>10)&0x1C)>>2;
        row.push([r,g,b]);
      }
      rows.push(row);
    }
  } else if(bpp===24){
    for(let y=0;y<h16;y++){
      const row=[];
      for(let x=0;x<w16;x++){
        const r=data[offset+2],g=data[offset+1],b=data[offset]; offset+=3;
        row.push([r,g,b]);
      }
      rows.push(row);
      offset = (y+1)*w16*2;
    }
  }
  return {bpp: bpp, clut: clut, data: rows, width: (bpp===4? w16*4: bpp===8? w16*2: bpp===24? (w16*2/3)|0:w16), height: h16};
}

// ======= FILE EXPORT =======
function saveFile(){
  if(!imageInfo) return;
  if(imageInfo.clut || imageInfo.bpp<24){
    alert("TIM save not implemented yet in this demo. Use Export PNG.");
    return;
  }
  exportPNG();
}

function exportPNG(){
  if(!imageInfo) return;
  const tempCanvas=document.createElement('canvas');
  tempCanvas.width=imageInfo.width; tempCanvas.height=imageInfo.height;
  const tctx=tempCanvas.getContext('2d');
  const imgData=tctx.createImageData(imageInfo.width,imageInfo.height);
  for(let y=0;y<imageInfo.height;y++){
    for(let x=0;x<imageInfo.width;x++){
      const i=(y*imageInfo.width+x)*4;
      let r,g,b;
      if(imageInfo.clut){ const idx=imageInfo.data[y][x]; [r,g,b]=imageInfo.clut[idx]; }
      else{ [r,g,b]=imageInfo.data[y][x]; }
      imgData.data[i]=r; imgData.data[i+1]=g; imgData.data[i+2]=b; imgData.data[i+3]=255;
    }
  }
  tctx.putImageData(imgData,0,0);
  tempCanvas.toBlob(blob=>{
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download="image.png";
    a.click();
  });
}

</script>
<p><a href="pages/webtools.html">‚Üê Go Back</a></p>
</body>
</html>
